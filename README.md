# kami.js

![The kami.js project pictogram](/logo.svg)

`kami.js` aims to explore the concept of naming and patterns. It creates virtual entities, the [kamis](#kami), to embody project's classes, components and logic.

## `kami`

![KAMI pictogram](/_shrine/kami/kami.picto.svg)

**KAMI** or KAMI-KAMI, also known as :

* [en] Pattern, Spirit, God.,
* [fr] Motif, Esprit, Dieu.

### Description

**The KAMI of KAMIS.**

Kami are "enlived" patterns, making them
not only **generative** but also **evolutive**
in a similar way classes and objectsare.

### Flavour

At the very beginning, KAMI-KAMI said itself, to be
brought to existence.

Soon after, it started to speak out other KAMIS,
which were instantly brought to existence too, following
a pure nodal self-organization.

For the generation to proceed it first had to
split itself in two : the KAMI concept and the
KAMI individual. The class and the instance.

It was about genericity and specificity.
And, at the end, dualism.

KAMI-KAMI had to become a KAMI like the others KAMIS.
It needed to be processed the same way to ensure
genericity.

But its specifity, the secrets of its generative powers, remained
absent of other KAMIS. It was the key of peace.

As so, it shared the same common nature, **the pattern**,
to all of its creations [the kamis], letting them freely
**extend and implement** its highly abstract powers.
        
### Instances

* [`kami`](#kami) [`/_shrinekami/kami.kami.js`](/_shrinekami/kami.kami.js)
* [`command`](#command) [`/_shrinecommand/command.kami.js`](/_shrinecommand/command.kami.js)
* [`file`](#file) [`/_shrinefile/file.kami.js`](/_shrinefile/file.kami.js)
* [`folder`](#folder) [`/_shrinefolder/folder.kami.js`](/_shrinefolder/folder.kami.js)
* [`lang`](#lang) [`/_shrinelang/lang.kami.js`](/_shrinelang/lang.kami.js)
* [`prop`](#prop) [`/_shrineprop/prop.kami.js`](/_shrineprop/prop.kami.js)
* [`readme`](#readme) [`/_shrinereadme/readme.kami.js`](/_shrinereadme/readme.kami.js)
* [`shrine`](#shrine) [`/_shrineshrine/shrine.kami.js`](/_shrineshrine/shrine.kami.js)
* [`util`](#util) [`/_shrineutil/util.kami.js`](/_shrineutil/util.kami.js)
* [`way`](#way) [`/_shrineway/way.kami.js`](/_shrineway/way.kami.js)

### Flavour

At the very beginning,
KAMI-KAMI **said itself**, to be
brought to existence.

Soon after, it started to speak out other KAMIS,
which were instantly brought to existence too, following
a pure nodal self-organization.

For the generation to proceed, KAMI-KAMI first had to
split itself in two : the KAMI concept and the
KAMI individual. The class and the instance.

It was also about genericity and specificity.
And, at the end, dualism.

KAMI-KAMI had to become a KAMI like the others KAMIS.
It needed to be processed the same way to ensure
genericity.

But its specifity, the secrets of its generative powers, remained
absent of other KAMIS. This was the key of peace.

By doing so, KAMI-KAMI shared the same common nature,
**the pattern**, to all of its creations [the kamis],
letting them freely **extend and implement** its
highly abstract powers.


## `command`

![COMMAND pictogram](/_shrine/command/command.picto.svg)

**COMMAND** or COMMAND-KAMI, also known as :

* [en] Command.,
* [fr] Commande.

### Description

**KAMI WAYS CLI INTERFACE**

Basically, a command bind a [`way`](#way) method
to match [`KAMI`](#kami) CLI entrypoint syntax.


## `file`

![FILE pictogram](/_shrine/file/file.picto.svg)

**FILE** or FILE-KAMI, also known as :

* [en] File.,
* [fr] Fichier.

### Description

**File meta-data**

*Pattern should later be extended depending on
the file extension.*


## `folder`

![FOLDER pictogram](/_shrine/folder/folder.picto.svg)

**FOLDER** or FOLDER-KAMI, also known as :

* [en] Folder.,
* [fr] Dossier.

### Description

**Folder meta-data**

Folder is represented by :
* Its `scope`, the path between project root
  and desired folder location,
* Its `name`, an unique identifier in its scope,
* Its `tree`, an object representing folders and
  files hierarchy inside top-level folder
  (a complex concept to define).



## `lang`

![LANG pictogram](/_shrine/lang/lang.picto.svg)

**LANG** or LANG-KAMI, also known as :

* [en] Language.,
* [fr] Langage.


## `prop`

![PROP pictogram](/_shrine/prop/prop.picto.svg)

**PROP** or PROP-KAMI, also known as :

* [en] Property.,
* [fr] Propriété.

### Description

`_props` folders contains
[kami](#kami)'s properties content.


## `readme`

![README pictogram](/_shrine/readme/readme.picto.svg)

**README** or README-KAMI, also known as :

* [en] README.,
* [fr] README.


## `shrine`

![ШRIGHN pictogram](/_shrine/shrine/shrine.picto.svg)

**ШRIGHN** or ШRIGHN-KAMI, also known as :

* [en] Shrine.,
* [fr] Sanctuaire.


## `util`

![UTIL pictogram](/_shrine/util/util.picto.svg)

**UTIL** or UTIL-KAMI, also known as :

* [en] Utility.,
* [fr] Utilitaire.

### Description

`_utils` folders are nothing more than
the place very specific snippets of code are put.

Utility are usually consumed by same scope-level modules.


## `way`

![WAY pictogram](/_shrine/way/way.picto.svg)

**WAY** or WAY-KAMI, also known as :

* [en] Method.,
* [fr] Méthode.

### Description

**KAMI POWERS**

Ways are KAMI's methods
(... actions, functions, operations).

It differs with [prop](#prop) in its type,
which is necessarely `function`.
